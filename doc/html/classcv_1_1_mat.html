<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>opencv: cv::Mat Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacecv.html">cv</a>      </li>
      <li><a class="el" href="classcv_1_1_mat.html">Mat</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<h1>cv::Mat Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="cv::Mat" -->
<p><code>#include &lt;<a class="el" href="core_8hpp_source.html">core.hpp</a>&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for cv::Mat:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classcv_1_1_mat.png" usemap="#cv::Mat_map" alt=""/>
  <map id="cv::Mat_map" name="cv::Mat_map">
<area href="classcv_1_1_mat__.html" alt="cv::Mat_&lt; _Tp &gt;" shape="rect" coords="0,56,105,80"/>
</map>
 </div><!-- endSectionContent --></div>

<p><a href="classcv_1_1_mat-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_mat_1_1_m_size.html">MSize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcv_1_1_mat_1_1_m_step.html">MStep</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classcv_1_1_mat.html#abafcd5cff0a8bf7fc3ce643c6c458b48a2082a2faa4b65dedcc5b84433c97f817">MAGIC_VAL</a> = 0x42FF0000, 
<a class="el" href="classcv_1_1_mat.html#abafcd5cff0a8bf7fc3ce643c6c458b48a1c147538fd896f4f9abce9eaea9727e3">AUTO_STEP</a> = 0, 
<a class="el" href="classcv_1_1_mat.html#abafcd5cff0a8bf7fc3ce643c6c458b48a3a50403178ba15a9617f5ff341418cf9">CONTINUOUS_FLAG</a> = CV_MAT_CONT_FLAG, 
<a class="el" href="classcv_1_1_mat.html#abafcd5cff0a8bf7fc3ce643c6c458b48a1db725f4a7efd16a41581b4fc54e7aad">SUBMATRIX_FLAG</a> = CV_SUBMAT_FLAG
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a9d3794250e3dc39714f980b4d0d45864">addref</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">increases the reference counter; use with care to avoid memleaks  <a href="#a9d3794250e3dc39714f980b4d0d45864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a2fece3507ee7e1284deee6da99e76b9b">adjustROI</a> (int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">moves/resizes the current matrix ROI inside the parent matrix.  <a href="#a2fece3507ee7e1284deee6da99e76b9b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1ae9e51754ae9e3577c567c635d06a72">assignTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, int type=-1) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a60dfdf355d77323fa5a2936995f1b3e3">at</a> (int i0=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the same as above, with the pointer dereferencing  <a href="#a60dfdf355d77323fa5a2936995f1b3e3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ab1796035719673695ea692e09370faf5">at</a> (int i0=0) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#acdec2fb38c9f34b062c0cebd5ef13d59">at</a> (int i0, int i1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a899e7c89459c8d8f8d00cfd0e848d9a9">at</a> (int i0, int i1) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aef4a38b7995bb4d50ce0dd1354a5bdbe">at</a> (int i0, int i1, int i2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#abbf2e4fd6f3eef2d8b3c9c0b3745d149">at</a> (int i0, int i1, int i2) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a56c3f86263f15cadec2601af2aa5f689">at</a> (const int *idx)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a406ee33dff19fff2e38fa8ae0da65e6e">at</a> (const int *idx) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6e7027f3ea3897c160d5f87c5857aeee">at</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;idx)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a3c853749394b114d9255675db88f042c">at</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;idx) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ab84bafe2a47a1a30ed9fde67e75d4abc">at</a> (<a class="el" href="classcv_1_1_point__.html">Point</a> pt)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">special versions for 2D arrays (especially convenient for referencing image pixels)  <a href="#ab84bafe2a47a1a30ed9fde67e75d4abc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a52b2b158cdb871a04c03ed58c2f1f168">at</a> (<a class="el" href="classcv_1_1_point__.html">Point</a> pt) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_iterator__.html">MatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a595d7b53cc170519ae1e68e868bb582f">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template methods for iteration over matrix elements.  <a href="#a595d7b53cc170519ae1e68e868bb582f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_const_iterator__.html">MatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a119a03913548522574513069d0076286">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a25a881a7ec5963714af7de1e4a63e521">channels</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns element type, similar to CV_MAT_CN(cvmat-&gt;type)  <a href="#a25a881a7ec5963714af7de1e4a63e521"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a39541d4dbd7fafbfae93f1737e51ffbc">checkVector</a> (int elemChannels, int depth=-1, bool requireContinuous=true) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise  <a href="#a39541d4dbd7fafbfae93f1737e51ffbc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#afb01ff6b2231b72f55618bfb66a5326b">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns deep copy of the matrix, i.e. the data is copied  <a href="#afb01ff6b2231b72f55618bfb66a5326b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ace2ab8cd964b5299c069c39f4f3318f4">col</a> (int <a class="el" href="highgui__c_8h.html#ad77deca22f617d3f0e0eb786445689fc">x</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new matrix header for the specified column  <a href="#ace2ab8cd964b5299c069c39f4f3318f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#afaa1adb197492153ae11bf690d4eaaea">colRange</a> (const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;r) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1138b6f6e9fc1f0d99d8bc0f595b9a20">colRange</a> (int startcol, int endcol) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">... for the specified column span  <a href="#a1138b6f6e9fc1f0d99d8bc0f595b9a20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a2e8e4141e6e2a4b504a8300aa45deaa0">convertTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, int rtype, double alpha=1, double beta=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts matrix to another datatype with optional scalng. See cvConvertScale.  <a href="#a2e8e4141e6e2a4b504a8300aa45deaa0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a39fd9880fc55b7a0993bcfff88061ac4">copySize</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">internal use function; properly re-allocates _size, _step arrays  <a href="#a39fd9880fc55b7a0993bcfff88061ac4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a93d41f0686c829fd293bfb09c5aa0d3f">copyTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies the matrix content to "m".  <a href="#a93d41f0686c829fd293bfb09c5aa0d3f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a28a159311cb0bdcaccb0bab8a12eaa7f">copyTo</a> (<a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;<a class="el" href="namespacecv.html#a2efcf76b229625667f9c282f913f7d07">mask</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies those matrix elements to "m" that are marked with non-zero mask elements.  <a href="#a28a159311cb0bdcaccb0bab8a12eaa7f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac084c2f8df748d4fb8387f8eb32e51af">copyTo</a> (vector&lt; _Tp &gt; &amp;v) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a8e1e3ce54ef27bfb07b88b6db807b480">create</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> _size, int _type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aef6575da9c9d0286c4687d6ddbb00788">create</a> (int _rows, int _cols, int _type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates new matrix data unless the matrix already has specified size and type.  <a href="#aef6575da9c9d0286c4687d6ddbb00788"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a47ccfd5b115f1aec5bdc99f84fa99683">create</a> (int _ndims, const int *_sizes, int _type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af22eb949a15144a145e9283ed0cadccb">cross</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes cross-product of 2 3D vectors  <a href="#af22eb949a15144a145e9283ed0cadccb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac6e9cdf9b450e360f005978b4e981b1a">deallocate</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">deallocates the matrix data  <a href="#ac6e9cdf9b450e360f005978b4e981b1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aaad7b287d4ea97236f6c506d2c4823a4">depth</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns element type, similar to CV_MAT_DEPTH(cvmat-&gt;type)  <a href="#aaad7b287d4ea97236f6c506d2c4823a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6a2cf5257b0e8436b9342df14a4797b7">diag</a> (int d=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">... for the specified diagonal  <a href="#a6a2cf5257b0e8436b9342df14a4797b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac2a05e801a408df5be90491639a52c89">dot</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">computes dot-product  <a href="#ac2a05e801a408df5be90491639a52c89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af72a7cf6705c102f05b5760db5d3b6ed">elemSize</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns element size in bytes,  <a href="#af72a7cf6705c102f05b5760db5d3b6ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a91e0bf81a49b68ca1d95fdf7dce58d30">elemSize1</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of element channel in bytes.  <a href="#a91e0bf81a49b68ca1d95fdf7dce58d30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a17d0777aef52a7cfbdb8d04d189fa5c3">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if matrix data is NULL  <a href="#a17d0777aef52a7cfbdb8d04d189fa5c3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_iterator__.html">MatIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a9c76e55962550636490f0bdd35f669a0">end</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_const_iterator__.html">MatConstIterator_</a>&lt; _Tp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aaf1d7e62bda9dc45ca82fb543888313c">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ae5702be79ebaf66a52db244c99e8fc09">inv</a> (int <a class="el" href="namespacecv.html#a4df92ae5110d3034ca8df254752f404e">method</a>=DECOMP_LU) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix inversion by means of matrix expressions  <a href="#ae5702be79ebaf66a52db244c99e8fc09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aff83775c7fc1479de5f4a8c4e67fe361">isContinuous</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff the matrix data is continuous  <a href="#aff83775c7fc1479de5f4a8c4e67fe361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#acd8efe61a20916729df5a6af29404045">isSubmatrix</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the matrix is a submatrix of another matrix  <a href="#acd8efe61a20916729df5a6af29404045"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af188277bef9a3c31dc8054519ba76d77">locateROI</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> &amp;wholeSize, <a class="el" href="classcv_1_1_point__.html">Point</a> &amp;ofs) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">locates matrix header within a parent matrix. See below  <a href="#af188277bef9a3c31dc8054519ba76d77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1cd663c089366877df2b666ac609bbde">Mat</a> (int _rows, int _cols, int _type, const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;_s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constucts 2D matrix and fills it with the specified value _s.  <a href="#a1cd663c089366877df2b666ac609bbde"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ace96eec32e872a59c69e0839e28dfc4a">Mat</a> (const <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> *m, bool copyData=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts old-style <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> to the new matrix; the data is not copied by default  <a href="#ace96eec32e872a59c69e0839e28dfc4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a294eaf8a95d2f9c7be19ff594d06278e">Mat</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a294eaf8a95d2f9c7be19ff594d06278e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a5bd19249b7951dd47b04304646404b5c">Mat</a> (const <a class="el" href="struct___ipl_image.html">IplImage</a> *img, bool copyData=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts old-style IplImage to the new matrix; the data is not copied by default  <a href="#a5bd19249b7951dd47b04304646404b5c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a083d116f0db8e67991f60ac0f7fbf7a5">Mat</a> (int _rows, int _cols, int _type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs 2D matrix of the specified size and type  <a href="#a083d116f0db8e67991f60ac0f7fbf7a5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a7d65237bb33769a0f785239ede9c0eac">Mat</a> (const vector&lt; _Tp &gt; &amp;vec, bool copyData=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds matrix from std::vector with or without copying the data  <a href="#a7d65237bb33769a0f785239ede9c0eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a65a7515778ed4045708af82c2f7eec63">Mat</a> (int _rows, int _cols, int _type, void *_data, size_t _step=AUTO_STEP)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for matrix headers pointing to user-allocated data  <a href="#a65a7515778ed4045708af82c2f7eec63"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ab2d7a287f04ee7b6873e794647db27bf">Mat</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; _Tp, n &gt; &amp;vec, bool copyData=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds matrix from <a class="el" href="classcv_1_1_vec.html">cv::Vec</a>; the data is copied by default  <a href="#ab2d7a287f04ee7b6873e794647db27bf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int m, int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a261cdae01d41f0a964f9e85ae99312b1">Mat</a> (const <a class="el" href="classcv_1_1_matx.html">Matx</a>&lt; _Tp, m, n &gt; &amp;mtx, bool copyData=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds matrix from <a class="el" href="classcv_1_1_matx.html">cv::Matx</a>; the data is copied by default  <a href="#a261cdae01d41f0a964f9e85ae99312b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a4f2ba3afb7980dbdfe676bc8e04fdbc4">Mat</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> _size, int _type, void *_data, size_t _step=AUTO_STEP)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa933725b02f4e261ead233aa742ae0ff">Mat</a> (const <a class="el" href="classcv_1_1_point__.html">Point_</a>&lt; _Tp &gt; &amp;pt, bool copyData=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds matrix from a 2D point  <a href="#aa933725b02f4e261ead233aa742ae0ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1315aee0375536d374630d6e7c42af44">Mat</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> _size, int _type, const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;_s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa80a8dc206f4c34422d7fae1459c5a35">Mat</a> (int _ndims, const int *_sizes, int _type, void *_data, const size_t *_steps=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#afb47ad1551aa0ecb4679fa580f0b35a1">Mat</a> (const <a class="el" href="classcv_1_1_point3__.html">Point3_</a>&lt; _Tp &gt; &amp;pt, bool copyData=true)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds matrix from a 3D point  <a href="#afb47ad1551aa0ecb4679fa580f0b35a1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a70b6f2d299b4ccb69f6c5d12878e4682">Mat</a> (const <a class="el" href="classcv_1_1_mat_comma_initializer__.html">MatCommaInitializer_</a>&lt; _Tp &gt; &amp;commaInitializer)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">builds matrix from comma initializer  <a href="#a70b6f2d299b4ccb69f6c5d12878e4682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a7468c000080be3dc814e8629fe724fd9">Mat</a> (int _ndims, const int *_sizes, int _type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs n-dimensional matrix  <a href="#a7468c000080be3dc814e8629fe724fd9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a92a3e9e5911a2eb0cf0950a0a9670c76">Mat</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;rowRange, const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;colRange=Range::all())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a matrix header for a part of the bigger matrix  <a href="#a92a3e9e5911a2eb0cf0950a0a9670c76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa7ec97373406215f2d4bc72cc1d27036">Mat</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, const <a class="el" href="classcv_1_1_rect__.html">Rect</a> &amp;roi)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc">Mat</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#af1d014cecd1510cdf580bf2ed7e5aafc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#afde22a742fc73c0a150a9002310ac2eb">Mat</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, const <a class="el" href="classcv_1_1_range.html">Range</a> *ranges)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ad7ff22c03258be6bd983d01daf465357">Mat</a> (int _ndims, const int *_sizes, int _type, const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;_s)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6bd47aeb10295ac550af449fe0c3e643">Mat</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> _size, int _type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac54e1c5025e8afd7641fd2a37a3deef7">Mat</a> (const <a class="el" href="struct_cv_mat.html">CvMat</a> *m, bool copyData=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts old-style <a class="el" href="struct_cv_mat.html">CvMat</a> to the new matrix; the data is not copied by default  <a href="#ac54e1c5025e8afd7641fd2a37a3deef7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a587af5543cc14cf6943fceee67999d1d">mul</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m, double <a class="el" href="namespacecv.html#a51a22470a6038d4d737a633730006770">scale</a>=1) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">per-element matrix multiplication by means of matrix expressions  <a href="#a587af5543cc14cf6943fceee67999d1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1910d44a3e836eb2a77f8e2956c5cbd0">mul</a> (const <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> &amp;m, double <a class="el" href="namespacecv.html#a51a22470a6038d4d737a633730006770">scale</a>=1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa09a1c7966df3ce9bb5b1d936354d868">operator CvMat</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts header to <a class="el" href="struct_cv_mat.html">CvMat</a>; no data is copied  <a href="#aa09a1c7966df3ce9bb5b1d936354d868"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a969350962e560db9cc1c0347f5b77359">operator CvMatND</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts header to <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a>; no data is copied  <a href="#a969350962e560db9cc1c0347f5b77359"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a58be4601818b7271611786bb554241c3">operator IplImage</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts header to IplImage; no data is copied  <a href="#a58be4601818b7271611786bb554241c3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int m, int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a5dbb019f5861dc47c7400e254ce376e0">operator Matx&lt; _Tp, m, n &gt;</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac15ff3356501adb655036ef532b2a00a">operator Vec&lt; _Tp, n &gt;</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aca1939448e17354e51d44f3572efca3d">operator vector&lt; _Tp &gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a639213bc2cb22d5215cee2d50fd38e0a">operator()</a> (<a class="el" href="classcv_1_1_range.html">Range</a> rowRange, <a class="el" href="classcv_1_1_range.html">Range</a> colRange) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">extracts a rectangular sub-matrix  <a href="#a639213bc2cb22d5215cee2d50fd38e0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a07413f2e3e63a12185b8b218c24c7270">operator()</a> (const <a class="el" href="classcv_1_1_rect__.html">Rect</a> &amp;roi) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af0802559a762f9871f2fa38868e762d6">operator()</a> (const <a class="el" href="classcv_1_1_range.html">Range</a> *ranges) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa5c947f7e449a4d856a4f3a87fcebd50">operator=</a> (const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sets every matrix element to s  <a href="#aa5c947f7e449a4d856a4f3a87fcebd50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a96257a78caabe909255cf0f96817d191">operator=</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operators  <a href="#a96257a78caabe909255cf0f96817d191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a27876fb2c9fb5d0937d8e31cf1cf06c7">operator=</a> (const <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> &amp;expr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a88bbb01901fdfe3f1d0592c592e8757c">pop_back</a> (size_t nelems=1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">removes several hyper-planes from bottom of the matrix  <a href="#a88bbb01901fdfe3f1d0592c592e8757c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a84b9f725ecb0e58d8e75c898b8ce0fb2">ptr</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;idx)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a079a0b4d3a19c96ea579576272d900b9">ptr</a> (int i0=0) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a09901bd3838a56c5da675dbe59ad1e87">ptr</a> (int i0, int i1) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#afd6c5ea76ffe733d2319af14500821f5">ptr</a> (int i0, int i1, int i2) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6d11a24d8852e142d363c2a5afe990d9">ptr</a> (const int *idx) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ab38357f3b3e648b56f43fa1d62b87d6f">ptr</a> (int i0, int i1, int i2) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac397d6f12fd76f2aa9c9bf7598f843b6">ptr</a> (int i0, int i1)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to (i0,i1) submatrix along the dimensions #0 and #1  <a href="#ac397d6f12fd76f2aa9c9bf7598f843b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af290f346f19f970aa5c5e1e62821ba38">ptr</a> (int i0, int i1) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a9477ea45db5c58d49dd8c5e09acac219">ptr</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a04e52e996208b33202e66e29db2843ee">ptr</a> (int i0=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to i0-th submatrix along the dimension #0  <a href="#a04e52e996208b33202e66e29db2843ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac0117ca8f94659c5f87474ad8f124e28">ptr</a> (int i0=0) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a8552084a40ea210fcb9831ace329b555">ptr</a> (const int *idx)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a97d1efafaaf6c43fd027b9b4739d8ecc">ptr</a> (int i0=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template version of the above method  <a href="#a97d1efafaaf6c43fd027b9b4739d8ecc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a57f94b838172efa4a961da52490f7f48">ptr</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;idx)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac7db9a7e4b26592f632b3620a8ff0590">ptr</a> (int i0, int i1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a757e5c21a5fc4484b5407b023e16604c">ptr</a> (int i0, int i1, int i2)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to (i0,i1,i3) submatrix along the dimensions #0, #1, #2  <a href="#a757e5c21a5fc4484b5407b023e16604c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int n&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6c72cb10fa42da70fe25da8621ec4631">ptr</a> (const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;idx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ac58d381fd0e05dbcd8bf43e5bb52ee0f">ptr</a> (const int *idx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns read-only pointer to the matrix element  <a href="#ac58d381fd0e05dbcd8bf43e5bb52ee0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a16ddf99556222fd8729ea4a9dc8f864e">ptr</a> (const int *idx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the matrix element  <a href="#a16ddf99556222fd8729ea4a9dc8f864e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aaca81482d6b0938804ac9ac9069e82c9">ptr</a> (int i0, int i1, int i2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a3676bae1741459eda3771e8653357c53">push_back</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;m)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6f01daa568843cb20cd19dce0aed1a77">push_back</a> (const <a class="el" href="classcv_1_1_mat__.html">Mat_</a>&lt; _Tp &gt; &amp;elem)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af11e514b13395e44909ba5bb52a1295e">push_back</a> (const _Tp &amp;elem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adds element to the end of 1d matrix (or possibly multiple elements when _Tp=Mat)  <a href="#af11e514b13395e44909ba5bb52a1295e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a57c658e2a97dda24fef1be2e625da914">push_back_</a> (const void *elem)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">internal function  <a href="#a57c658e2a97dda24fef1be2e625da914"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ae48d4913285518e2c21a3457017e716e">release</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">decreases reference counter;  <a href="#ae48d4913285518e2c21a3457017e716e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a0706ed6c42e288926c5ad415b976bbe2">reserve</a> (size_t sz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">reserves enough space to fit sz hyper-planes  <a href="#a0706ed6c42e288926c5ad415b976bbe2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a565b3a02346a76fae3f8854e604b9546">reshape</a> (int _cn, int _newndims, const int *_newsz) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#adbca7d35259c060dbd9346a6ccff6bba">reshape</a> (int _cn, int _rows=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">creates alternative matrix header for the same data, with different  <a href="#adbca7d35259c060dbd9346a6ccff6bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#abdbf4852beb3af95977fa289f6c7034c">resize</a> (size_t sz, const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">resizes matrix to the specified number of hyper-planes; initializes the newly added elements  <a href="#abdbf4852beb3af95977fa289f6c7034c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ad0127b138acfcc2dcd5dafc51175b309">resize</a> (size_t sz)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">resizes matrix to the specified number of hyper-planes  <a href="#ad0127b138acfcc2dcd5dafc51175b309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#acce30f9c4475038ee86ea8b24e00850a">row</a> (int <a class="el" href="highgui__c_8h.html#a9298c7ad619074f5285b32c6b72bfdea">y</a>) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a new matrix header for the specified row  <a href="#acce30f9c4475038ee86ea8b24e00850a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a41f404b47717a0216d4e2ec16390e406">rowRange</a> (const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;r) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa5c442a1c548e3c686dbc57be60c7fad">rowRange</a> (int startrow, int endrow) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">... for the specified row span  <a href="#aa5c442a1c548e3c686dbc57be60c7fad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a53bd9b635ccac48bb44ebcdeeb9dc676">setTo</a> (const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;s, const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;<a class="el" href="namespacecv.html#a2efcf76b229625667f9c282f913f7d07">mask</a>=<a class="el" href="classcv_1_1_mat.html">Mat</a>())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sets some of the matrix elements to s, according to the mask  <a href="#a53bd9b635ccac48bb44ebcdeeb9dc676"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a5f28c2a73273c124941ca625fe731d06">step1</a> (int i=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns step/elemSize1()  <a href="#a5f28c2a73273c124941ca625fe731d06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a286d072cdb3d01e4171d0ff4dadb7d2c">t</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">matrix transposition by means of matrix expressions  <a href="#a286d072cdb3d01e4171d0ff4dadb7d2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1e30c0e178bf85b1d6491666bf4bc8de">total</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the total number of matrix elements  <a href="#a1e30c0e178bf85b1d6491666bf4bc8de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa6477efc7399fbe742418250ccf99a4b">type</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns element type, similar to CV_MAT_TYPE(cvmat-&gt;type)  <a href="#aa6477efc7399fbe742418250ccf99a4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a1b2ae166171f6a7306cf09ff67a2153f">~Mat</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor - calls <a class="el" href="classcv_1_1_mat.html#ae48d4913285518e2c21a3457017e716e" title="decreases reference counter;">release()</a>  <a href="#a1b2ae166171f6a7306cf09ff67a2153f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat.html">Mat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#ae7106e127bf5ad7203bc87336303ff8a">diag</a> (const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;d)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs a square diagonal matrix which main diagonal is vector "d"  <a href="#ae7106e127bf5ad7203bc87336303ff8a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a2cf9b9acde7a9852542bbc20ef851ed2">eye</a> (int <a class="el" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">rows</a>, int <a class="el" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>, int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aab87b56e1dc370ffe4afb735b6a1e5c9">eye</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> <a class="el" href="classcv_1_1_mat.html#a5500ed91b9300d78a62528c4f7bf1869">size</a>, int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a6ed33f15d7bf0172efb62d61b3751284">ones</a> (int ndims, const int *sz, int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a69ae0402d116fc9c71908d8508dc2f09">ones</a> (int <a class="el" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">rows</a>, int <a class="el" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>, int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#afc9c2c0b17ecd00932bc5fbc72f9bce0">ones</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> <a class="el" href="classcv_1_1_mat.html#a5500ed91b9300d78a62528c4f7bf1869">size</a>, int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a961cf7d4f82253d93bb5b8ff54522087">zeros</a> (int ndims, const int *sz, int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a0b57b6a326c8876d944d188a46e0f556">zeros</a> (int <a class="el" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">rows</a>, int <a class="el" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>, int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Matlab-style matrix initialization.  <a href="#a0b57b6a326c8876d944d188a46e0f556"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a095db10924bc801644a29074a755b6e9">zeros</a> (<a class="el" href="classcv_1_1_size__.html">Size</a> <a class="el" href="classcv_1_1_mat.html#a5500ed91b9300d78a62528c4f7bf1869">size</a>, int type)</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcv_1_1_mat_allocator.html">MatAllocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a4d2eb7a536cd5a0f18808b6112111d6a">allocator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">custom allocator  <a href="#a4d2eb7a536cd5a0f18808b6112111d6a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a4d33bed1c850265370d2af0ff02e1564">data</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the data  <a href="#a4d33bed1c850265370d2af0ff02e1564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a717e658d46d705f4c4863b67cade70d8">dataend</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a0dd9da61f74d2e82c38bf729baad5bdb">datalimit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a3c094be66d6a19b74c93d57a502a59d0">datastart</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper fields used in locateROI and adjustROI  <a href="#a3c094be66d6a19b74c93d57a502a59d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a39cf614aa52567e9a945cd2609bd767b">dims</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the matrix dimensionality, &gt;= 2  <a href="#a39cf614aa52567e9a945cd2609bd767b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#af9333f06c84f115fda4cdf3af18c2ad0">flags</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a731b10faf33879e2d6a0ebd0fcce4ce4">refcount</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to the reference counter;  <a href="#a731b10faf33879e2d6a0ebd0fcce4ce4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">rows</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions  <a href="#abed816466c45234254d25bc59c31245e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_mat_1_1_m_size.html">MSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#a5500ed91b9300d78a62528c4f7bf1869">size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcv_1_1_mat_1_1_m_step.html">MStep</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcv_1_1_mat.html#acc7e087cdfcaaba5df75ab6e9def9e85">step</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The n-dimensional matrix class.</p>
<p>The class represents an n-dimensional dense numerical array that can act as a matrix, image, optical flow map, 3-focal tensor etc. It is very similar to <a class="el" href="struct_cv_mat.html">CvMat</a> and <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> types from earlier versions of OpenCV, and similarly to those types, the matrix can be multi-channel. It also fully supports ROI mechanism.</p>
<p>There are many different ways to create <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> object. Here are the some popular ones: </p>
<ul>
<li>
<p class="startli">using cv::Mat::create(nrows, ncols, type) method or the similar constructor cv::Mat::Mat(nrows, ncols, type[, fill_value]) constructor. A new matrix of the specified size and specifed type will be allocated. "type" has the same meaning as in cvCreateMat function, e.g. CV_8UC1 means 8-bit single-channel matrix, CV_32FC2 means 2-channel (i.e. complex) floating-point matrix etc:</p>
<div class="fragment"><pre class="fragment">     <span class="comment">// make 7x7 complex matrix filled with 1+3j.</span>
     <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> M(7,7,<a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a15d6109d87682bf909122d0ce51c46a6">CV_32FC2</a>,<a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>(1,3));
     <span class="comment">// and now turn M to 100x60 15-channel 8-bit matrix.</span>
     <span class="comment">// The old content will be deallocated</span>
     M.create(100,60,<a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a78c5506f62d99edd7e83aba259250394">CV_8UC</a>(15));
</pre></div><p>As noted in the introduction of this chapter, <a class="el" href="classcv_1_1_mat.html#aef6575da9c9d0286c4687d6ddbb00788" title="allocates new matrix data unless the matrix already has specified size and type.">Mat::create()</a> will only allocate a new matrix when the current matrix dimensionality or type are different from the specified.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">by using a copy constructor or assignment operator, where on the right side it can be a matrix or expression, see below. Again, as noted in the introduction, matrix assignment is O(1) operation because it only copies the header and increases the reference counter. <a class="el" href="classcv_1_1_mat.html#afb01ff6b2231b72f55618bfb66a5326b" title="returns deep copy of the matrix, i.e. the data is copied">cv::Mat::clone()</a> method can be used to get a full (a.k.a. deep) copy of the matrix when you need it.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">by constructing a header for a part of another matrix. It can be a single row, single column, several rows, several columns, rectangular region in the matrix (called a minor in algebra) or a diagonal. Such operations are also O(1), because the new header will reference the same data. You can actually modify a part of the matrix using this feature, e.g.</p>
<div class="fragment"><pre class="fragment">     <span class="comment">// add 5-th row, multiplied by 3 to the 3rd row</span>
     M.row(3) = M.row(3) + M.row(5)*3;

     <span class="comment">// now copy 7-th column to the 1-st column</span>
     <span class="comment">// M.col(1) = M.col(7); // this will not work</span>
     <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">Mat</a> M1 = M.col(1);
     M.col(7).copyTo(M1);

     <span class="comment">// create new 320x240 image</span>
     <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> img(<a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a>(320,240),<a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>);
     <span class="comment">// select a roi</span>
     <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> roi(img, <a class="code" href="namespacecv.html#a954f5c2ab7c3f0f5d4eed444cdabf038">Rect</a>(10,10,100,100));
     <span class="comment">// fill the ROI with (0,255,0) (which is green in RGB space);</span>
     <span class="comment">// the original 320x240 image will be modified</span>
     roi = <a class="code" href="namespacecv.html#a599fe92e910c027be274233eccad7beb">Scalar</a>(0,255,0);
</pre></div><p>Thanks to the additional <a class="el" href="classcv_1_1_mat.html#a3c094be66d6a19b74c93d57a502a59d0" title="helper fields used in locateROI and adjustROI">cv::Mat::datastart</a> and <a class="el" href="classcv_1_1_mat.html#a717e658d46d705f4c4863b67cade70d8">cv::Mat::dataend</a> members, it is possible to compute the relative sub-matrix position in the main "container" matrix using <a class="el" href="classcv_1_1_mat.html#af188277bef9a3c31dc8054519ba76d77" title="locates matrix header within a parent matrix. See below">cv::Mat::locateROI()</a>:</p>
<div class="fragment"><pre class="fragment">     <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">Mat</a> A = <a class="code" href="classcv_1_1_mat.html#a2cf9b9acde7a9852542bbc20ef851ed2">Mat::eye</a>(10, 10, <a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a4067910fc388075c3ea3aa14393e83b9">CV_32S</a>);
     <span class="comment">// extracts A columns, 1 (inclusive) to 3 (exclusive).</span>
     <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">Mat</a> B = A(<a class="code" href="classcv_1_1_range.html#a0fb943fbfbb6598cfba5e48223335ce0">Range::all</a>(), Range(1, 3));
     <span class="comment">// extracts B rows, 5 (inclusive) to 9 (exclusive).</span>
     <span class="comment">// that is, C ~ A(Range(5, 9), Range(1, 3))</span>
     <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">Mat</a> C = B(Range(5, 9), <a class="code" href="classcv_1_1_range.html#a0fb943fbfbb6598cfba5e48223335ce0">Range::all</a>());
     <a class="code" href="namespacecv.html#a346f563897249351a34549137c8532a0">Size</a> <a class="code" href="classcv_1_1_mat.html#a5500ed91b9300d78a62528c4f7bf1869">size</a>; <a class="code" href="namespacecv.html#a1e83eafb2d26b3c93f09e8338bcab192">Point</a> ofs;
     C.locateROI(size, ofs);
     <span class="comment">// size will be (width=10,height=10) and the ofs will be (x=1, y=5)</span>
</pre></div><p>As in the case of whole matrices, if you need a deep copy, use <a class="el" href="classcv_1_1_mat.html#afb01ff6b2231b72f55618bfb66a5326b" title="returns deep copy of the matrix, i.e. the data is copied">cv::Mat::clone()</a> method of the extracted sub-matrices.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">by making a header for user-allocated-data. It can be useful for </p>
<ol>
<li>
<p class="startli">processing "foreign" data using OpenCV (e.g. when you implement a DirectShow filter or a processing module for gstreamer etc.), e.g.</p>
<div class="fragment"><pre class="fragment">         <span class="keywordtype">void</span> process_video_frame(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pixels,
                                  <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> <a class="code" href="classcv_1_1_mat.html#acc7e087cdfcaaba5df75ab6e9def9e85">step</a>)
         {
            <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> img(height, width, <a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a88c4cd9de76f678f33928ef1e3f96047">CV_8UC3</a>, pixels, step);
            cv::GaussianBlur(img, img, <a class="code" href="classcv_1_1_size__.html">cv::Size</a>(7,7), 1.5, 1.5);
         }
</pre></div><p class="endli"></p>
</li>
<li>
<p class="startli">for quick initialization of small matrices and/or super-fast element access</p>
<div class="fragment"><pre class="fragment">         <span class="keywordtype">double</span> m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};
         <a class="code" href="classcv_1_1_mat.html">cv::Mat</a> M = <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">cv::Mat</a>(3, 3, <a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a30a562691cc5987bc88eb7bb7a8faf2b">CV_64F</a>, m).inv();
</pre></div> </li>
</ol>
<p>partial yet very common cases of this "user-allocated data" case are conversions from <a class="el" href="struct_cv_mat.html">CvMat</a> and IplImage to <a class="el" href="classcv_1_1_mat.html">cv::Mat</a>. For this purpose there are special constructors taking pointers to <a class="el" href="struct_cv_mat.html">CvMat</a> or IplImage and the optional flag indicating whether to copy the data or not.</p>
<p>Backward conversion from <a class="el" href="classcv_1_1_mat.html">cv::Mat</a> to <a class="el" href="struct_cv_mat.html">CvMat</a> or IplImage is provided via cast operators cv::Mat::operator <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#aa73c9f09385a947975066f8c039cbd6d">CvMat()</a> an cv::Mat::operator <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a249298f383f3b430b476542076320c57">IplImage()</a>. The operators do not copy the data.</p>
<div class="fragment"><pre class="fragment">       <a class="code" href="struct___ipl_image.html">IplImage</a>* img = <a class="code" href="highgui__c_8h.html#a8026ee03c8c6a9031a3e36fd18937c1b">cvLoadImage</a>(<span class="stringliteral">&quot;greatwave.jpg&quot;</span>, 1);
       <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">Mat</a> mtx(img); <span class="comment">// convert IplImage* -&gt; cv::Mat</span>
       <a class="code" href="struct_cv_mat.html">CvMat</a> oldmat = mtx; <span class="comment">// convert cv::Mat -&gt; CvMat</span>
       <a class="code" href="core_8hpp.html#af62bcd90f70e275191ab95136d85906b">CV_Assert</a>(oldmat.<a class="code" href="struct_cv_mat.html#ad3706bc15c75d94d1a938172b2f790b5">cols</a> == img-&gt;<a class="code" href="struct___ipl_image.html#af6e81897beca2d2d9914949912cd7b32">width</a> &amp;&amp; oldmat.<a class="code" href="struct_cv_mat.html#a1048c94607682732dc75d367f7777222">rows</a> == img-&gt;<a class="code" href="struct___ipl_image.html#a760ffed837a60c6606047177697d97f3">height</a> &amp;&amp;
           oldmat.<a class="code" href="struct_cv_mat.html#ac2b7b9adfc47d9d8b567115dc970bf72">data</a>.<a class="code" href="struct_cv_mat.html#a788228568bc88fbfd4ccae75a9d01585">ptr</a> == (<a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>*)img-&gt;<a class="code" href="struct___ipl_image.html#a8f494e96def4231c3623eead920b3358">imageData</a> &amp;&amp; oldmat.<a class="code" href="struct_cv_mat.html#a79ac05ef6fed1529e6d4b444c7c5234c">step</a> == img-&gt;<a class="code" href="struct___ipl_image.html#aca744fd03a4a3ccf8b896798a09c2784">widthStep</a>);
</pre></div><p class="endli"></p>
</li>
<li>
<p class="startli">by using MATLAB-style matrix initializers, <a class="el" href="classcv_1_1_mat.html#a0b57b6a326c8876d944d188a46e0f556" title="Matlab-style matrix initialization.">cv::Mat::zeros()</a>, <a class="el" href="classcv_1_1_mat.html#a69ae0402d116fc9c71908d8508dc2f09">cv::Mat::ones()</a>, <a class="el" href="classcv_1_1_mat.html#a2cf9b9acde7a9852542bbc20ef851ed2">cv::Mat::eye()</a>, e.g.:</p>
<div class="fragment"><pre class="fragment">   <span class="comment">// create a double-precision identity martix and add it to M.</span>
   M += <a class="code" href="classcv_1_1_mat.html#a2cf9b9acde7a9852542bbc20ef851ed2">Mat::eye</a>(M.<a class="code" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e" title="the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions">rows</a>, M.<a class="code" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>, <a class="code" href="core_2include_2opencv2_2core_2types__c_8h.html#a30a562691cc5987bc88eb7bb7a8faf2b">CV_64F</a>);
</pre></div><p class="endli"></p>
</li>
<li>
<p class="startli">by using comma-separated initializer:</p>
<div class="fragment"><pre class="fragment">   <span class="comment">// create 3x3 double-precision identity matrix</span>
   <a class="code" href="classcv_1_1_mat.html#af1d014cecd1510cdf580bf2ed7e5aafc" title="default constructor">Mat</a> M = (Mat_&lt;double&gt;(3,3) &lt;&lt; 1, 0, 0, 0, 1, 0, 0, 0, 1);
</pre></div><p>here we first call constructor of <a class="el" href="classcv_1_1_mat__.html">cv::Mat_</a> class (that we describe further) with the proper matrix, and then we just put "&lt;&lt;" operator followed by comma-separated values that can be constants, variables, expressions etc. Also, note the extra parentheses that are needed to avoid compiler errors.</p>
<p class="endli"></p>
</li>
</ul>
<p>Once matrix is created, it will be automatically managed by using reference-counting mechanism (unless the matrix header is built on top of user-allocated data, in which case you should handle the data by yourself). The matrix data will be deallocated when no one points to it; if you want to release the data pointed by a matrix header before the matrix destructor is called, use <a class="el" href="classcv_1_1_mat.html#ae48d4913285518e2c21a3457017e716e" title="decreases reference counter;">cv::Mat::release()</a>.</p>
<p>The next important thing to learn about the matrix class is element access. Here is how the matrix is stored. The elements are stored in row-major order (row by row). The <a class="el" href="classcv_1_1_mat.html#a4d33bed1c850265370d2af0ff02e1564" title="pointer to the data">cv::Mat::data</a> member points to the first element of the first row, <a class="el" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e" title="the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions">cv::Mat::rows</a> contains the number of matrix rows and <a class="el" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cv::Mat::cols</a> - the number of matrix columns. There is yet another member, <a class="el" href="classcv_1_1_mat.html#acc7e087cdfcaaba5df75ab6e9def9e85">cv::Mat::step</a> that is used to actually compute address of a matrix element. <a class="el" href="classcv_1_1_mat.html#acc7e087cdfcaaba5df75ab6e9def9e85">cv::Mat::step</a> is needed because the matrix can be a part of another matrix or because there can some padding space in the end of each row for a proper alignment.</p>
<div align="center">
<img src="roi.png" alt="roi.png"/>
</div>
<p>Given these parameters, address of the matrix element M_{ij} is computed as following:</p>
<p>addr(M_{ij})=M.data + M.step*i + j*M.<a class="el" href="classcv_1_1_mat.html#af72a7cf6705c102f05b5760db5d3b6ed" title="returns element size in bytes,">elemSize()</a></p>
<p>if you know the matrix element type, e.g. it is float, then you can use <a class="el" href="classcv_1_1_mat.html#a60dfdf355d77323fa5a2936995f1b3e3" title="the same as above, with the pointer dereferencing">cv::Mat::at()</a> method:</p>
<p>addr(M_{ij})=&amp;M.at&lt;float&gt;(i,j)</p>
<p>(where &amp; is used to convert the reference returned by <a class="el" href="classcv_1_1_mat.html#a60dfdf355d77323fa5a2936995f1b3e3" title="the same as above, with the pointer dereferencing">cv::Mat::at()</a> to a pointer). if you need to process a whole row of matrix, the most efficient way is to get the pointer to the row first, and then just use plain C operator []:</p>
<div class="fragment"><pre class="fragment">   <span class="comment">// compute sum of positive matrix elements</span>
   <span class="comment">// (assuming that M is double-precision matrix)</span>
   <span class="keywordtype">double</span> <a class="code" href="namespacecv.html#a812b04b300feed9639f49480260137c4">sum</a>=0;
   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; M.rows; i++)
   {
       <span class="keyword">const</span> <span class="keywordtype">double</span>* Mi = M.ptr&lt;<span class="keywordtype">double</span>&gt;(i);
       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; M.cols; j++)
           sum += <a class="code" href="namespacecv.html#a57416e28468db6ec3f09e4a133a2c224" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::max</a>(Mi[j], 0.);
   }
</pre></div><p>Some operations, like the above one, do not actually depend on the matrix shape, they just process elements of a matrix one by one (or elements from multiple matrices that are sitting in the same place, e.g. matrix addition). Such operations are called element-wise and it makes sense to check whether all the input/output matrices are continuous, i.e. have no gaps in the end of each row, and if yes, process them as a single long row:</p>
<div class="fragment"><pre class="fragment">   <span class="comment">// compute sum of positive matrix elements, optimized variant</span>
   <span class="keywordtype">double</span> sum=0;
   <span class="keywordtype">int</span> <a class="code" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a> = M.cols, <a class="code" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e" title="the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions">rows</a> = M.rows;
   <span class="keywordflow">if</span>(M.isContinuous())
   {
       cols *= <a class="code" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e" title="the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions">rows</a>;
       <a class="code" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e" title="the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions">rows</a> = 1;
   }
   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e" title="the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions">rows</a>; i++)
   {
       <span class="keyword">const</span> <span class="keywordtype">double</span>* Mi = M.ptr&lt;<span class="keywordtype">double</span>&gt;(i);
       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cols</a>; j++)
           sum += <a class="code" href="namespacecv.html#a57416e28468db6ec3f09e4a133a2c224" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::max</a>(Mi[j], 0.);
   }
</pre></div><p> in the case of continuous matrix the outer loop body will be executed just once, so the overhead will be smaller, which will be especially noticeable in the case of small matrices.</p>
<p>Finally, there are STL-style iterators that are smart enough to skip gaps between successive rows: </p>
<div class="fragment"><pre class="fragment">   <span class="comment">// compute sum of positive matrix elements, iterator-based variant</span>
   <span class="keywordtype">double</span> sum=0;
   MatConstIterator_&lt;double&gt; it = M.begin&lt;<span class="keywordtype">double</span>&gt;(), it_end = M.end&lt;<span class="keywordtype">double</span>&gt;();
   <span class="keywordflow">for</span>(; it != it_end; ++it)
       sum += <a class="code" href="namespacecv.html#a57416e28468db6ec3f09e4a133a2c224" title="computes per-element maximum of two arrays (dst = max(src1, src2))">std::max</a>(*it, 0.);
</pre></div><p>The matrix iterators are random-access iterators, so they can be passed to any STL algorithm, including std::sort(). </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="abafcd5cff0a8bf7fc3ce643c6c458b48"></a><!-- doxytag: member="cv::Mat::@40" ref="abafcd5cff0a8bf7fc3ce643c6c458b48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abafcd5cff0a8bf7fc3ce643c6c458b48a2082a2faa4b65dedcc5b84433c97f817"></a><!-- doxytag: member="MAGIC_VAL" ref="abafcd5cff0a8bf7fc3ce643c6c458b48a2082a2faa4b65dedcc5b84433c97f817" args="" -->MAGIC_VAL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abafcd5cff0a8bf7fc3ce643c6c458b48a1c147538fd896f4f9abce9eaea9727e3"></a><!-- doxytag: member="AUTO_STEP" ref="abafcd5cff0a8bf7fc3ce643c6c458b48a1c147538fd896f4f9abce9eaea9727e3" args="" -->AUTO_STEP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abafcd5cff0a8bf7fc3ce643c6c458b48a3a50403178ba15a9617f5ff341418cf9"></a><!-- doxytag: member="CONTINUOUS_FLAG" ref="abafcd5cff0a8bf7fc3ce643c6c458b48a3a50403178ba15a9617f5ff341418cf9" args="" -->CONTINUOUS_FLAG</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abafcd5cff0a8bf7fc3ce643c6c458b48a1db725f4a7efd16a41581b4fc54e7aad"></a><!-- doxytag: member="SUBMATRIX_FLAG" ref="abafcd5cff0a8bf7fc3ce643c6c458b48a1db725f4a7efd16a41581b4fc54e7aad" args="" -->SUBMATRIX_FLAG</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af1d014cecd1510cdf580bf2ed7e5aafc"></a><!-- doxytag: member="cv::Mat::Mat" ref="af1d014cecd1510cdf580bf2ed7e5aafc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a class="anchor" id="a083d116f0db8e67991f60ac0f7fbf7a5"></a><!-- doxytag: member="cv::Mat::Mat" ref="a083d116f0db8e67991f60ac0f7fbf7a5" args="(int _rows, int _cols, int _type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs 2D matrix of the specified size and type </p>

</div>
</div>
<a class="anchor" id="a6bd47aeb10295ac550af449fe0c3e643"></a><!-- doxytag: member="cv::Mat::Mat" ref="a6bd47aeb10295ac550af449fe0c3e643" args="(Size _size, int _type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1cd663c089366877df2b666ac609bbde"></a><!-- doxytag: member="cv::Mat::Mat" ref="a1cd663c089366877df2b666ac609bbde" args="(int _rows, int _cols, int _type, const Scalar &amp;_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"> <em>_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constucts 2D matrix and fills it with the specified value _s. </p>

</div>
</div>
<a class="anchor" id="a1315aee0375536d374630d6e7c42af44"></a><!-- doxytag: member="cv::Mat::Mat" ref="a1315aee0375536d374630d6e7c42af44" args="(Size _size, int _type, const Scalar &amp;_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"> <em>_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7468c000080be3dc814e8629fe724fd9"></a><!-- doxytag: member="cv::Mat::Mat" ref="a7468c000080be3dc814e8629fe724fd9" args="(int _ndims, const int *_sizes, int _type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs n-dimensional matrix </p>

</div>
</div>
<a class="anchor" id="ad7ff22c03258be6bd983d01daf465357"></a><!-- doxytag: member="cv::Mat::Mat" ref="ad7ff22c03258be6bd983d01daf465357" args="(int _ndims, const int *_sizes, int _type, const Scalar &amp;_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"> <em>_s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a294eaf8a95d2f9c7be19ff594d06278e"></a><!-- doxytag: member="cv::Mat::Mat" ref="a294eaf8a95d2f9c7be19ff594d06278e" args="(const Mat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a class="anchor" id="a65a7515778ed4045708af82c2f7eec63"></a><!-- doxytag: member="cv::Mat::Mat" ref="a65a7515778ed4045708af82c2f7eec63" args="(int _rows, int _cols, int _type, void *_data, size_t _step=AUTO_STEP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>_step</em> = <code>AUTO_STEP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for matrix headers pointing to user-allocated data </p>

</div>
</div>
<a class="anchor" id="a4f2ba3afb7980dbdfe676bc8e04fdbc4"></a><!-- doxytag: member="cv::Mat::Mat" ref="a4f2ba3afb7980dbdfe676bc8e04fdbc4" args="(Size _size, int _type, void *_data, size_t _step=AUTO_STEP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>_step</em> = <code>AUTO_STEP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa80a8dc206f4c34422d7fae1459c5a35"></a><!-- doxytag: member="cv::Mat::Mat" ref="aa80a8dc206f4c34422d7fae1459c5a35" args="(int _ndims, const int *_sizes, int _type, void *_data, const size_t *_steps=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"> <em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"> <em>_steps</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a92a3e9e5911a2eb0cf0950a0a9670c76"></a><!-- doxytag: member="cv::Mat::Mat" ref="a92a3e9e5911a2eb0cf0950a0a9670c76" args="(const Mat &amp;m, const Range &amp;rowRange, const Range &amp;colRange=Range::all())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"> <em>rowRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"> <em>colRange</em> = <code>Range::all()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creates a matrix header for a part of the bigger matrix </p>

</div>
</div>
<a class="anchor" id="aa7ec97373406215f2d4bc72cc1d27036"></a><!-- doxytag: member="cv::Mat::Mat" ref="aa7ec97373406215f2d4bc72cc1d27036" args="(const Mat &amp;m, const Rect &amp;roi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_rect__.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"> <em>roi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afde22a742fc73c0a150a9002310ac2eb"></a><!-- doxytag: member="cv::Mat::Mat" ref="afde22a742fc73c0a150a9002310ac2eb" args="(const Mat &amp;m, const Range *ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_range.html">Range</a> *&#160;</td>
          <td class="paramname"> <em>ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac54e1c5025e8afd7641fd2a37a3deef7"></a><!-- doxytag: member="cv::Mat::Mat" ref="ac54e1c5025e8afd7641fd2a37a3deef7" args="(const CvMat *m, bool copyData=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_cv_mat.html">CvMat</a> *&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts old-style <a class="el" href="struct_cv_mat.html">CvMat</a> to the new matrix; the data is not copied by default </p>

</div>
</div>
<a class="anchor" id="ace96eec32e872a59c69e0839e28dfc4a"></a><!-- doxytag: member="cv::Mat::Mat" ref="ace96eec32e872a59c69e0839e28dfc4a" args="(const CvMatND *m, bool copyData=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> *&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts old-style <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> to the new matrix; the data is not copied by default </p>

</div>
</div>
<a class="anchor" id="a5bd19249b7951dd47b04304646404b5c"></a><!-- doxytag: member="cv::Mat::Mat" ref="a5bd19249b7951dd47b04304646404b5c" args="(const IplImage *img, bool copyData=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct___ipl_image.html">IplImage</a> *&#160;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts old-style IplImage to the new matrix; the data is not copied by default </p>

</div>
</div>
<a class="anchor" id="a7d65237bb33769a0f785239ede9c0eac"></a><!-- doxytag: member="cv::Mat::Mat" ref="a7d65237bb33769a0f785239ede9c0eac" args="(const vector&lt; _Tp &gt; &amp;vec, bool copyData=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>builds matrix from std::vector with or without copying the data </p>

</div>
</div>
<a class="anchor" id="ab2d7a287f04ee7b6873e794647db27bf"></a><!-- doxytag: member="cv::Mat::Mat" ref="ab2d7a287f04ee7b6873e794647db27bf" args="(const Vec&lt; _Tp, n &gt; &amp;vec, bool copyData=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; _Tp, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>builds matrix from <a class="el" href="classcv_1_1_vec.html">cv::Vec</a>; the data is copied by default </p>

</div>
</div>
<a class="anchor" id="a261cdae01d41f0a964f9e85ae99312b1"></a><!-- doxytag: member="cv::Mat::Mat" ref="a261cdae01d41f0a964f9e85ae99312b1" args="(const Matx&lt; _Tp, m, n &gt; &amp;mtx, bool copyData=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int m, int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_matx.html">Matx</a>&lt; _Tp, m, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>builds matrix from <a class="el" href="classcv_1_1_matx.html">cv::Matx</a>; the data is copied by default </p>

</div>
</div>
<a class="anchor" id="aa933725b02f4e261ead233aa742ae0ff"></a><!-- doxytag: member="cv::Mat::Mat" ref="aa933725b02f4e261ead233aa742ae0ff" args="(const Point_&lt; _Tp &gt; &amp;pt, bool copyData=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_point__.html">Point_</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"> <em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>builds matrix from a 2D point </p>

</div>
</div>
<a class="anchor" id="afb47ad1551aa0ecb4679fa580f0b35a1"></a><!-- doxytag: member="cv::Mat::Mat" ref="afb47ad1551aa0ecb4679fa580f0b35a1" args="(const Point3_&lt; _Tp &gt; &amp;pt, bool copyData=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_point3__.html">Point3_</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"> <em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>copyData</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>builds matrix from a 3D point </p>

</div>
</div>
<a class="anchor" id="a70b6f2d299b4ccb69f6c5d12878e4682"></a><!-- doxytag: member="cv::Mat::Mat" ref="a70b6f2d299b4ccb69f6c5d12878e4682" args="(const MatCommaInitializer_&lt; _Tp &gt; &amp;commaInitializer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::Mat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat_comma_initializer__.html">MatCommaInitializer_</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"> <em>commaInitializer</em>&#160;)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>builds matrix from comma initializer </p>

</div>
</div>
<a class="anchor" id="a1b2ae166171f6a7306cf09ff67a2153f"></a><!-- doxytag: member="cv::Mat::~Mat" ref="a1b2ae166171f6a7306cf09ff67a2153f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::~Mat </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>destructor - calls <a class="el" href="classcv_1_1_mat.html#ae48d4913285518e2c21a3457017e716e" title="decreases reference counter;">release()</a> </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9d3794250e3dc39714f980b4d0d45864"></a><!-- doxytag: member="cv::Mat::addref" ref="a9d3794250e3dc39714f980b4d0d45864" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::addref </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>increases the reference counter; use with care to avoid memleaks </p>

</div>
</div>
<a class="anchor" id="a2fece3507ee7e1284deee6da99e76b9b"></a><!-- doxytag: member="cv::Mat::adjustROI" ref="a2fece3507ee7e1284deee6da99e76b9b" args="(int dtop, int dbottom, int dleft, int dright)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a>&amp; cv::Mat::adjustROI </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>moves/resizes the current matrix ROI inside the parent matrix. </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#af91e57d5048ea744c47abd084d0b8e0f">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1ae9e51754ae9e3577c567c635d06a72"></a><!-- doxytag: member="cv::Mat::assignTo" ref="a1ae9e51754ae9e3577c567c635d06a72" args="(Mat &amp;m, int type=&#45;1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::assignTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a60dfdf355d77323fa5a2936995f1b3e3"></a><!-- doxytag: member="cv::Mat::at" ref="a60dfdf355d77323fa5a2936995f1b3e3" args="(int i0=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em> = <code>0</code>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the same as above, with the pointer dereferencing </p>

</div>
</div>
<a class="anchor" id="ab1796035719673695ea692e09370faf5"></a><!-- doxytag: member="cv::Mat::at" ref="ab1796035719673695ea692e09370faf5" args="(int i0=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em> = <code>0</code>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a52b2b158cdb871a04c03ed58c2f1f168"></a><!-- doxytag: member="cv::Mat::at" ref="a52b2b158cdb871a04c03ed58c2f1f168" args="(Point pt) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_point__.html">Point</a>&#160;</td>
          <td class="paramname"> <em>pt</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acdec2fb38c9f34b062c0cebd5ef13d59"></a><!-- doxytag: member="cv::Mat::at" ref="acdec2fb38c9f34b062c0cebd5ef13d59" args="(int i0, int i1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a899e7c89459c8d8f8d00cfd0e848d9a9"></a><!-- doxytag: member="cv::Mat::at" ref="a899e7c89459c8d8f8d00cfd0e848d9a9" args="(int i0, int i1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aef4a38b7995bb4d50ce0dd1354a5bdbe"></a><!-- doxytag: member="cv::Mat::at" ref="aef4a38b7995bb4d50ce0dd1354a5bdbe" args="(int i0, int i1, int i2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abbf2e4fd6f3eef2d8b3c9c0b3745d149"></a><!-- doxytag: member="cv::Mat::at" ref="abbf2e4fd6f3eef2d8b3c9c0b3745d149" args="(int i0, int i1, int i2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a56c3f86263f15cadec2601af2aa5f689"></a><!-- doxytag: member="cv::Mat::at" ref="a56c3f86263f15cadec2601af2aa5f689" args="(const int *idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a406ee33dff19fff2e38fa8ae0da65e6e"></a><!-- doxytag: member="cv::Mat::at" ref="a406ee33dff19fff2e38fa8ae0da65e6e" args="(const int *idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e7027f3ea3897c160d5f87c5857aeee"></a><!-- doxytag: member="cv::Mat::at" ref="a6e7027f3ea3897c160d5f87c5857aeee" args="(const Vec&lt; int, n &gt; &amp;idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c853749394b114d9255675db88f042c"></a><!-- doxytag: member="cv::Mat::at" ref="a3c853749394b114d9255675db88f042c" args="(const Vec&lt; int, n &gt; &amp;idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp&amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab84bafe2a47a1a30ed9fde67e75d4abc"></a><!-- doxytag: member="cv::Mat::at" ref="ab84bafe2a47a1a30ed9fde67e75d4abc" args="(Point pt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp &amp; cv::Mat::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_point__.html">Point</a>&#160;</td>
          <td class="paramname"> <em>pt</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>special versions for 2D arrays (especially convenient for referencing image pixels) </p>

</div>
</div>
<a class="anchor" id="a595d7b53cc170519ae1e68e868bb582f"></a><!-- doxytag: member="cv::Mat::begin" ref="a595d7b53cc170519ae1e68e868bb582f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_iterator__.html">MatIterator_</a>&lt; _Tp &gt; cv::Mat::begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template methods for iteration over matrix elements. </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ae02daa883bc296c9155219088568f7e7">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a119a03913548522574513069d0076286"></a><!-- doxytag: member="cv::Mat::begin" ref="a119a03913548522574513069d0076286" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_const_iterator__.html">MatConstIterator_</a>&lt; _Tp &gt; cv::Mat::begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#af10e05c8397eea40a1177e5de331761e">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a25a881a7ec5963714af7de1e4a63e521"></a><!-- doxytag: member="cv::Mat::channels" ref="a25a881a7ec5963714af7de1e4a63e521" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cv::Mat::channels </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns element type, similar to CV_MAT_CN(cvmat-&gt;type) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ace2da405cbb8da7092628764c124816e">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a39541d4dbd7fafbfae93f1737e51ffbc"></a><!-- doxytag: member="cv::Mat::checkVector" ref="a39541d4dbd7fafbfae93f1737e51ffbc" args="(int elemChannels, int depth=&#45;1, bool requireContinuous=true) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cv::Mat::checkVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>elemChannels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>depth</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>requireContinuous</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise </p>

</div>
</div>
<a class="anchor" id="afb01ff6b2231b72f55618bfb66a5326b"></a><!-- doxytag: member="cv::Mat::clone" ref="afb01ff6b2231b72f55618bfb66a5326b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::clone </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns deep copy of the matrix, i.e. the data is copied </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ad114ed300cfd9f6e16e70f5af6cd67a0">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ace2ab8cd964b5299c069c39f4f3318f4"></a><!-- doxytag: member="cv::Mat::col" ref="ace2ab8cd964b5299c069c39f4f3318f4" args="(int x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a new matrix header for the specified column </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a26c1b65eba7c04cc94accfbbd4e2bac2">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afaa1adb197492153ae11bf690d4eaaea"></a><!-- doxytag: member="cv::Mat::colRange" ref="afaa1adb197492153ae11bf690d4eaaea" args="(const Range &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::colRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"> <em>r</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1138b6f6e9fc1f0d99d8bc0f595b9a20"></a><!-- doxytag: member="cv::Mat::colRange" ref="a1138b6f6e9fc1f0d99d8bc0f595b9a20" args="(int startcol, int endcol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::colRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>startcol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>endcol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>... for the specified column span </p>

</div>
</div>
<a class="anchor" id="a2e8e4141e6e2a4b504a8300aa45deaa0"></a><!-- doxytag: member="cv::Mat::convertTo" ref="a2e8e4141e6e2a4b504a8300aa45deaa0" args="(Mat &amp;m, int rtype, double alpha=1, double beta=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>beta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts matrix to another datatype with optional scalng. See cvConvertScale. </p>

</div>
</div>
<a class="anchor" id="a39fd9880fc55b7a0993bcfff88061ac4"></a><!-- doxytag: member="cv::Mat::copySize" ref="a39fd9880fc55b7a0993bcfff88061ac4" args="(const Mat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::copySize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>internal use function; properly re-allocates _size, _step arrays </p>

</div>
</div>
<a class="anchor" id="a93d41f0686c829fd293bfb09c5aa0d3f"></a><!-- doxytag: member="cv::Mat::copyTo" ref="a93d41f0686c829fd293bfb09c5aa0d3f" args="(Mat &amp;m) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copies the matrix content to "m". </p>

</div>
</div>
<a class="anchor" id="ac084c2f8df748d4fb8387f8eb32e51af"></a><!-- doxytag: member="cv::Mat::copyTo" ref="ac084c2f8df748d4fb8387f8eb32e51af" args="(vector&lt; _Tp &gt; &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::copyTo </td>
          <td>(</td>
          <td class="paramtype">vector&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"> <em>v</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a28a159311cb0bdcaccb0bab8a12eaa7f"></a><!-- doxytag: member="cv::Mat::copyTo" ref="a28a159311cb0bdcaccb0bab8a12eaa7f" args="(Mat &amp;m, const Mat &amp;mask) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copies those matrix elements to "m" that are marked with non-zero mask elements. </p>

</div>
</div>
<a class="anchor" id="aef6575da9c9d0286c4687d6ddbb00788"></a><!-- doxytag: member="cv::Mat::create" ref="aef6575da9c9d0286c4687d6ddbb00788" args="(int _rows, int _cols, int _type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates new matrix data unless the matrix already has specified size and type. </p>

</div>
</div>
<a class="anchor" id="a47ccfd5b115f1aec5bdc99f84fa99683"></a><!-- doxytag: member="cv::Mat::create" ref="a47ccfd5b115f1aec5bdc99f84fa99683" args="(int _ndims, const int *_sizes, int _type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e1e3ce54ef27bfb07b88b6db807b480"></a><!-- doxytag: member="cv::Mat::create" ref="a8e1e3ce54ef27bfb07b88b6db807b480" args="(Size _size, int _type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af22eb949a15144a145e9283ed0cadccb"></a><!-- doxytag: member="cv::Mat::cross" ref="af22eb949a15144a145e9283ed0cadccb" args="(const Mat &amp;m) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes cross-product of 2 3D vectors </p>

</div>
</div>
<a class="anchor" id="ac6e9cdf9b450e360f005978b4e981b1a"></a><!-- doxytag: member="cv::Mat::deallocate" ref="ac6e9cdf9b450e360f005978b4e981b1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::deallocate </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>deallocates the matrix data </p>

</div>
</div>
<a class="anchor" id="aaad7b287d4ea97236f6c506d2c4823a4"></a><!-- doxytag: member="cv::Mat::depth" ref="aaad7b287d4ea97236f6c506d2c4823a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cv::Mat::depth </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns element type, similar to CV_MAT_DEPTH(cvmat-&gt;type) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a91854cefee382a2ead2bc691ac9cf41a">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6a2cf5257b0e8436b9342df14a4797b7"></a><!-- doxytag: member="cv::Mat::diag" ref="a6a2cf5257b0e8436b9342df14a4797b7" args="(int d=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::diag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>d</em> = <code>0</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>... for the specified diagonal </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ac940e6839236133014d77ebb8717c6ed">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae7106e127bf5ad7203bc87336303ff8a"></a><!-- doxytag: member="cv::Mat::diag" ref="ae7106e127bf5ad7203bc87336303ff8a" args="(const Mat &amp;d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::diag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>d</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructs a square diagonal matrix which main diagonal is vector "d" </p>

</div>
</div>
<a class="anchor" id="ac2a05e801a408df5be90491639a52c89"></a><!-- doxytag: member="cv::Mat::dot" ref="ac2a05e801a408df5be90491639a52c89" args="(const Mat &amp;m) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cv::Mat::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>computes dot-product </p>

</div>
</div>
<a class="anchor" id="af72a7cf6705c102f05b5760db5d3b6ed"></a><!-- doxytag: member="cv::Mat::elemSize" ref="af72a7cf6705c102f05b5760db5d3b6ed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cv::Mat::elemSize </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns element size in bytes, </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ab76741aad767a3574eae164742e3d7b5">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a91e0bf81a49b68ca1d95fdf7dce58d30"></a><!-- doxytag: member="cv::Mat::elemSize1" ref="a91e0bf81a49b68ca1d95fdf7dce58d30" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cv::Mat::elemSize1 </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size of element channel in bytes. </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a9667acbed43ae6d910d7023de41ce7e5">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a17d0777aef52a7cfbdb8d04d189fa5c3"></a><!-- doxytag: member="cv::Mat::empty" ref="a17d0777aef52a7cfbdb8d04d189fa5c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cv::Mat::empty </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns true if matrix data is NULL </p>

</div>
</div>
<a class="anchor" id="a9c76e55962550636490f0bdd35f669a0"></a><!-- doxytag: member="cv::Mat::end" ref="a9c76e55962550636490f0bdd35f669a0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_iterator__.html">MatIterator_</a>&lt; _Tp &gt; cv::Mat::end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ac33828864f625df221405cacc1cd09ae">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aaf1d7e62bda9dc45ca82fb543888313c"></a><!-- doxytag: member="cv::Mat::end" ref="aaf1d7e62bda9dc45ca82fb543888313c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_const_iterator__.html">MatConstIterator_</a>&lt; _Tp &gt; cv::Mat::end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ab6b3f20dbdfde8d11d506c8e3a8c34ff">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2cf9b9acde7a9852542bbc20ef851ed2"></a><!-- doxytag: member="cv::Mat::eye" ref="a2cf9b9acde7a9852542bbc20ef851ed2" args="(int rows, int cols, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::eye </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aab87b56e1dc370ffe4afb735b6a1e5c9"></a><!-- doxytag: member="cv::Mat::eye" ref="aab87b56e1dc370ffe4afb735b6a1e5c9" args="(Size size, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::eye </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5702be79ebaf66a52db244c99e8fc09"></a><!-- doxytag: member="cv::Mat::inv" ref="ae5702be79ebaf66a52db244c99e8fc09" args="(int method=DECOMP_LU) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::inv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>method</em> = <code>DECOMP_LU</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>matrix inversion by means of matrix expressions </p>

</div>
</div>
<a class="anchor" id="aff83775c7fc1479de5f4a8c4e67fe361"></a><!-- doxytag: member="cv::Mat::isContinuous" ref="aff83775c7fc1479de5f4a8c4e67fe361" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cv::Mat::isContinuous </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns true iff the matrix data is continuous </p>

</div>
</div>
<a class="anchor" id="acd8efe61a20916729df5a6af29404045"></a><!-- doxytag: member="cv::Mat::isSubmatrix" ref="acd8efe61a20916729df5a6af29404045" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cv::Mat::isSubmatrix </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns true if the matrix is a submatrix of another matrix </p>

</div>
</div>
<a class="anchor" id="af188277bef9a3c31dc8054519ba76d77"></a><!-- doxytag: member="cv::Mat::locateROI" ref="af188277bef9a3c31dc8054519ba76d77" args="(Size &amp;wholeSize, Point &amp;ofs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::locateROI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a> &amp;&#160;</td>
          <td class="paramname"> <em>wholeSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_point__.html">Point</a> &amp;&#160;</td>
          <td class="paramname"> <em>ofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>locates matrix header within a parent matrix. See below </p>

</div>
</div>
<a class="anchor" id="a587af5543cc14cf6943fceee67999d1d"></a><!-- doxytag: member="cv::Mat::mul" ref="a587af5543cc14cf6943fceee67999d1d" args="(const Mat &amp;m, double scale=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>per-element matrix multiplication by means of matrix expressions </p>

</div>
</div>
<a class="anchor" id="a1910d44a3e836eb2a77f8e2956c5cbd0"></a><!-- doxytag: member="cv::Mat::mul" ref="a1910d44a3e836eb2a77f8e2956c5cbd0" args="(const MatExpr &amp;m, double scale=1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::mul </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"> <em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6ed33f15d7bf0172efb62d61b3751284"></a><!-- doxytag: member="cv::Mat::ones" ref="a6ed33f15d7bf0172efb62d61b3751284" args="(int ndims, const int *sz, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::ones </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69ae0402d116fc9c71908d8508dc2f09"></a><!-- doxytag: member="cv::Mat::ones" ref="a69ae0402d116fc9c71908d8508dc2f09" args="(int rows, int cols, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::ones </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afc9c2c0b17ecd00932bc5fbc72f9bce0"></a><!-- doxytag: member="cv::Mat::ones" ref="afc9c2c0b17ecd00932bc5fbc72f9bce0" args="(Size size, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa09a1c7966df3ce9bb5b1d936354d868"></a><!-- doxytag: member="cv::Mat::operator CvMat" ref="aa09a1c7966df3ce9bb5b1d936354d868" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::operator <a class="el" href="struct_cv_mat.html">CvMat</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts header to <a class="el" href="struct_cv_mat.html">CvMat</a>; no data is copied </p>

</div>
</div>
<a class="anchor" id="a969350962e560db9cc1c0347f5b77359"></a><!-- doxytag: member="cv::Mat::operator CvMatND" ref="a969350962e560db9cc1c0347f5b77359" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::operator <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts header to <a class="el" href="struct_cv_mat_n_d.html">CvMatND</a>; no data is copied </p>

</div>
</div>
<a class="anchor" id="a58be4601818b7271611786bb554241c3"></a><!-- doxytag: member="cv::Mat::operator IplImage" ref="a58be4601818b7271611786bb554241c3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::operator <a class="el" href="struct___ipl_image.html">IplImage</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts header to IplImage; no data is copied </p>

</div>
</div>
<a class="anchor" id="a5dbb019f5861dc47c7400e254ce376e0"></a><!-- doxytag: member="cv::Mat::operator Matx&lt; _Tp, m, n &gt;" ref="a5dbb019f5861dc47c7400e254ce376e0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int m, int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::operator <a class="el" href="classcv_1_1_matx.html">Matx</a>&lt; _Tp, m, n &gt; </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac15ff3356501adb655036ef532b2a00a"></a><!-- doxytag: member="cv::Mat::operator Vec&lt; _Tp, n &gt;" ref="ac15ff3356501adb655036ef532b2a00a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::operator <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; _Tp, n &gt; </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aca1939448e17354e51d44f3572efca3d"></a><!-- doxytag: member="cv::Mat::operator vector&lt; _Tp &gt;" ref="aca1939448e17354e51d44f3572efca3d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat::operator vector&lt; _Tp &gt; </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a4bd4fb54488127fcc0e90db4a0ad5faa">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a639213bc2cb22d5215cee2d50fd38e0a"></a><!-- doxytag: member="cv::Mat::operator()" ref="a639213bc2cb22d5215cee2d50fd38e0a" args="(Range rowRange, Range colRange) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_range.html">Range</a>&#160;</td>
          <td class="paramname"> <em>rowRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcv_1_1_range.html">Range</a>&#160;</td>
          <td class="paramname"> <em>colRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>extracts a rectangular sub-matrix </p>

</div>
</div>
<a class="anchor" id="a07413f2e3e63a12185b8b218c24c7270"></a><!-- doxytag: member="cv::Mat::operator()" ref="a07413f2e3e63a12185b8b218c24c7270" args="(const Rect &amp;roi) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_rect__.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"> <em>roi</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a0f926e88a46a5acd3f0435dbebf81d59">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af0802559a762f9871f2fa38868e762d6"></a><!-- doxytag: member="cv::Mat::operator()" ref="af0802559a762f9871f2fa38868e762d6" args="(const Range *ranges) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_range.html">Range</a> *&#160;</td>
          <td class="paramname"> <em>ranges</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#aa2958acedbad6cc717e3f7e0d15b3f72">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a27876fb2c9fb5d0937d8e31cf1cf06c7"></a><!-- doxytag: member="cv::Mat::operator=" ref="a27876fb2c9fb5d0937d8e31cf1cf06c7" args="(const MatExpr &amp;expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp; cv::Mat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> &amp;&#160;</td>
          <td class="paramname"> <em>expr</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ac67b71eca5040c3f65db838bab30e1ca">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa5c947f7e449a4d856a4f3a87fcebd50"></a><!-- doxytag: member="cv::Mat::operator=" ref="aa5c947f7e449a4d856a4f3a87fcebd50" args="(const Scalar &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a>&amp; cv::Mat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"> <em>s</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets every matrix element to s </p>

</div>
</div>
<a class="anchor" id="a96257a78caabe909255cf0f96817d191"></a><!-- doxytag: member="cv::Mat::operator=" ref="a96257a78caabe909255cf0f96817d191" args="(const Mat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> &amp; cv::Mat::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assignment operators </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#aaf0a716e3b34ed09d87b64cf4e725ab4">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a88bbb01901fdfe3f1d0592c592e8757c"></a><!-- doxytag: member="cv::Mat::pop_back" ref="a88bbb01901fdfe3f1d0592c592e8757c" args="(size_t nelems=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::pop_back </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>nelems</em> = <code>1</code>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes several hyper-planes from bottom of the matrix </p>

</div>
</div>
<a class="anchor" id="a09901bd3838a56c5da675dbe59ad1e87"></a><!-- doxytag: member="cv::Mat::ptr" ref="a09901bd3838a56c5da675dbe59ad1e87" args="(int i0, int i1) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a97d1efafaaf6c43fd027b9b4739d8ecc"></a><!-- doxytag: member="cv::Mat::ptr" ref="a97d1efafaaf6c43fd027b9b4739d8ecc" args="(int i0=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em> = <code>0</code>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template version of the above method </p>

</div>
</div>
<a class="anchor" id="ac58d381fd0e05dbcd8bf43e5bb52ee0f"></a><!-- doxytag: member="cv::Mat::ptr" ref="ac58d381fd0e05dbcd8bf43e5bb52ee0f" args="(const int *idx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns read-only pointer to the matrix element </p>

</div>
</div>
<a class="anchor" id="a16ddf99556222fd8729ea4a9dc8f864e"></a><!-- doxytag: member="cv::Mat::ptr" ref="a16ddf99556222fd8729ea4a9dc8f864e" args="(const int *idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the matrix element </p>

</div>
</div>
<a class="anchor" id="afd6c5ea76ffe733d2319af14500821f5"></a><!-- doxytag: member="cv::Mat::ptr" ref="afd6c5ea76ffe733d2319af14500821f5" args="(int i0, int i1, int i2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac397d6f12fd76f2aa9c9bf7598f843b6"></a><!-- doxytag: member="cv::Mat::ptr" ref="ac397d6f12fd76f2aa9c9bf7598f843b6" args="(int i0, int i1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to (i0,i1) submatrix along the dimensions #0 and #1 </p>

</div>
</div>
<a class="anchor" id="a9477ea45db5c58d49dd8c5e09acac219"></a><!-- doxytag: member="cv::Mat::ptr" ref="a9477ea45db5c58d49dd8c5e09acac219" args="(const Vec&lt; int, n &gt; &amp;idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af290f346f19f970aa5c5e1e62821ba38"></a><!-- doxytag: member="cv::Mat::ptr" ref="af290f346f19f970aa5c5e1e62821ba38" args="(int i0, int i1) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a04e52e996208b33202e66e29db2843ee"></a><!-- doxytag: member="cv::Mat::ptr" ref="a04e52e996208b33202e66e29db2843ee" args="(int i0=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Tp * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em> = <code>0</code>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to i0-th submatrix along the dimension #0 </p>

</div>
</div>
<a class="anchor" id="ac0117ca8f94659c5f87474ad8f124e28"></a><!-- doxytag: member="cv::Mat::ptr" ref="ac0117ca8f94659c5f87474ad8f124e28" args="(int i0=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const _Tp * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em> = <code>0</code>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a757e5c21a5fc4484b5407b023e16604c"></a><!-- doxytag: member="cv::Mat::ptr" ref="a757e5c21a5fc4484b5407b023e16604c" args="(int i0, int i1, int i2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> * cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to (i0,i1,i3) submatrix along the dimensions #0, #1, #2 </p>

</div>
</div>
<a class="anchor" id="ab38357f3b3e648b56f43fa1d62b87d6f"></a><!-- doxytag: member="cv::Mat::ptr" ref="ab38357f3b3e648b56f43fa1d62b87d6f" args="(int i0, int i1, int i2) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a57f94b838172efa4a961da52490f7f48"></a><!-- doxytag: member="cv::Mat::ptr" ref="a57f94b838172efa4a961da52490f7f48" args="(const Vec&lt; int, n &gt; &amp;idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6c72cb10fa42da70fe25da8621ec4631"></a><!-- doxytag: member="cv::Mat::ptr" ref="a6c72cb10fa42da70fe25da8621ec4631" args="(const Vec&lt; int, n &gt; &amp;idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac7db9a7e4b26592f632b3620a8ff0590"></a><!-- doxytag: member="cv::Mat::ptr" ref="ac7db9a7e4b26592f632b3620a8ff0590" args="(int i0, int i1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8552084a40ea210fcb9831ace329b555"></a><!-- doxytag: member="cv::Mat::ptr" ref="a8552084a40ea210fcb9831ace329b555" args="(const int *idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a84b9f725ecb0e58d8e75c898b8ce0fb2"></a><!-- doxytag: member="cv::Mat::ptr" ref="a84b9f725ecb0e58d8e75c898b8ce0fb2" args="(const Vec&lt; int, n &gt; &amp;idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , int n&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_vec.html">Vec</a>&lt; int, n &gt; &amp;&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaca81482d6b0938804ac9ac9069e82c9"></a><!-- doxytag: member="cv::Mat::ptr" ref="aaca81482d6b0938804ac9ac9069e82c9" args="(int i0, int i1, int i2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d11a24d8852e142d363c2a5afe990d9"></a><!-- doxytag: member="cv::Mat::ptr" ref="a6d11a24d8852e142d363c2a5afe990d9" args="(const int *idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>idx</em>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a079a0b4d3a19c96ea579576272d900b9"></a><!-- doxytag: member="cv::Mat::ptr" ref="a079a0b4d3a19c96ea579576272d900b9" args="(int i0=0) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp* cv::Mat::ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i0</em> = <code>0</code>&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f01daa568843cb20cd19dce0aed1a77"></a><!-- doxytag: member="cv::Mat::push_back" ref="a6f01daa568843cb20cd19dce0aed1a77" args="(const Mat_&lt; _Tp &gt; &amp;elem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat__.html">Mat_</a>&lt; _Tp &gt; &amp;&#160;</td>
          <td class="paramname"> <em>elem</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3676bae1741459eda3771e8653357c53"></a><!-- doxytag: member="cv::Mat::push_back" ref="a3676bae1741459eda3771e8653357c53" args="(const Mat &amp;m)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>m</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af11e514b13395e44909ba5bb52a1295e"></a><!-- doxytag: member="cv::Mat::push_back" ref="af11e514b13395e44909ba5bb52a1295e" args="(const _Tp &amp;elem)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::push_back </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"> <em>elem</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>adds element to the end of 1d matrix (or possibly multiple elements when _Tp=Mat) </p>

</div>
</div>
<a class="anchor" id="a57c658e2a97dda24fef1be2e625da914"></a><!-- doxytag: member="cv::Mat::push_back_" ref="a57c658e2a97dda24fef1be2e625da914" args="(const void *elem)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::push_back_ </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"> <em>elem</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>internal function </p>

</div>
</div>
<a class="anchor" id="ae48d4913285518e2c21a3457017e716e"></a><!-- doxytag: member="cv::Mat::release" ref="ae48d4913285518e2c21a3457017e716e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::release </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>decreases reference counter; </p>

</div>
</div>
<a class="anchor" id="a0706ed6c42e288926c5ad415b976bbe2"></a><!-- doxytag: member="cv::Mat::reserve" ref="a0706ed6c42e288926c5ad415b976bbe2" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>sz</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>reserves enough space to fit sz hyper-planes </p>

</div>
</div>
<a class="anchor" id="adbca7d35259c060dbd9346a6ccff6bba"></a><!-- doxytag: member="cv::Mat::reshape" ref="adbca7d35259c060dbd9346a6ccff6bba" args="(int _cn, int _rows=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_rows</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>creates alternative matrix header for the same data, with different </p>

</div>
</div>
<a class="anchor" id="a565b3a02346a76fae3f8854e604b9546"></a><!-- doxytag: member="cv::Mat::reshape" ref="a565b3a02346a76fae3f8854e604b9546" args="(int _cn, int _newndims, const int *_newsz) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::reshape </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_cn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>_newndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>_newsz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abdbf4852beb3af95977fa289f6c7034c"></a><!-- doxytag: member="cv::Mat::resize" ref="abdbf4852beb3af95977fa289f6c7034c" args="(size_t sz, const Scalar &amp;s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"> <em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>resizes matrix to the specified number of hyper-planes; initializes the newly added elements </p>

</div>
</div>
<a class="anchor" id="ad0127b138acfcc2dcd5dafc51175b309"></a><!-- doxytag: member="cv::Mat::resize" ref="ad0127b138acfcc2dcd5dafc51175b309" args="(size_t sz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cv::Mat::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"> <em>sz</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>resizes matrix to the specified number of hyper-planes </p>

</div>
</div>
<a class="anchor" id="acce30f9c4475038ee86ea8b24e00850a"></a><!-- doxytag: member="cv::Mat::row" ref="acce30f9c4475038ee86ea8b24e00850a" args="(int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>y</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns a new matrix header for the specified row </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a1b07fa12b827018460aeb48f50bb02f2">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa5c442a1c548e3c686dbc57be60c7fad"></a><!-- doxytag: member="cv::Mat::rowRange" ref="aa5c442a1c548e3c686dbc57be60c7fad" args="(int startrow, int endrow) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::rowRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>startrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>endrow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>... for the specified row span </p>

</div>
</div>
<a class="anchor" id="a41f404b47717a0216d4e2ec16390e406"></a><!-- doxytag: member="cv::Mat::rowRange" ref="a41f404b47717a0216d4e2ec16390e406" args="(const Range &amp;r) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a> cv::Mat::rowRange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_range.html">Range</a> &amp;&#160;</td>
          <td class="paramname"> <em>r</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a53bd9b635ccac48bb44ebcdeeb9dc676"></a><!-- doxytag: member="cv::Mat::setTo" ref="a53bd9b635ccac48bb44ebcdeeb9dc676" args="(const Scalar &amp;s, const Mat &amp;mask=Mat())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat.html">Mat</a>&amp; cv::Mat::setTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_scalar__.html">Scalar</a> &amp;&#160;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcv_1_1_mat.html">Mat</a> &amp;&#160;</td>
          <td class="paramname"> <em>mask</em> = <code><a class="el" href="classcv_1_1_mat.html">Mat</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets some of the matrix elements to s, according to the mask </p>

</div>
</div>
<a class="anchor" id="a5f28c2a73273c124941ca625fe731d06"></a><!-- doxytag: member="cv::Mat::step1" ref="a5f28c2a73273c124941ca625fe731d06" args="(int i=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cv::Mat::step1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>i</em> = <code>0</code>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns step/elemSize1() </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#a8c8702424790f947f6857ad2672d1b63">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a286d072cdb3d01e4171d0ff4dadb7d2c"></a><!-- doxytag: member="cv::Mat::t" ref="a286d072cdb3d01e4171d0ff4dadb7d2c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::t </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>matrix transposition by means of matrix expressions </p>

</div>
</div>
<a class="anchor" id="a1e30c0e178bf85b1d6491666bf4bc8de"></a><!-- doxytag: member="cv::Mat::total" ref="a1e30c0e178bf85b1d6491666bf4bc8de" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cv::Mat::total </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the total number of matrix elements </p>

</div>
</div>
<a class="anchor" id="aa6477efc7399fbe742418250ccf99a4b"></a><!-- doxytag: member="cv::Mat::type" ref="aa6477efc7399fbe742418250ccf99a4b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cv::Mat::type </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns element type, similar to CV_MAT_TYPE(cvmat-&gt;type) </p>

<p>Reimplemented in <a class="el" href="classcv_1_1_mat__.html#ad049d5f8816aa3e8c2e8584ea0a9c437">cv::Mat_&lt; _Tp &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a0b57b6a326c8876d944d188a46e0f556"></a><!-- doxytag: member="cv::Mat::zeros" ref="a0b57b6a326c8876d944d188a46e0f556" args="(int rows, int cols, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::zeros </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Matlab-style matrix initialization. </p>

</div>
</div>
<a class="anchor" id="a961cf7d4f82253d93bb5b8ff54522087"></a><!-- doxytag: member="cv::Mat::zeros" ref="a961cf7d4f82253d93bb5b8ff54522087" args="(int ndims, const int *sz, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::zeros </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>ndims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"> <em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a095db10924bc801644a29074a755b6e9"></a><!-- doxytag: member="cv::Mat::zeros" ref="a095db10924bc801644a29074a755b6e9" args="(Size size, int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcv_1_1_mat_expr.html">MatExpr</a> cv::Mat::zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcv_1_1_size__.html">Size</a>&#160;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> <em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a4d2eb7a536cd5a0f18808b6112111d6a"></a><!-- doxytag: member="cv::Mat::allocator" ref="a4d2eb7a536cd5a0f18808b6112111d6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcv_1_1_mat_allocator.html">MatAllocator</a>* <a class="el" href="classcv_1_1_mat.html#a4d2eb7a536cd5a0f18808b6112111d6a">cv::Mat::allocator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>custom allocator </p>

</div>
</div>
<a class="anchor" id="aa3e5a47585c9ef6a0842556739155e3e"></a><!-- doxytag: member="cv::Mat::cols" ref="aa3e5a47585c9ef6a0842556739155e3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_mat.html#aa3e5a47585c9ef6a0842556739155e3e">cv::Mat::cols</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d33bed1c850265370d2af0ff02e1564"></a><!-- doxytag: member="cv::Mat::data" ref="a4d33bed1c850265370d2af0ff02e1564" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_mat.html#a4d33bed1c850265370d2af0ff02e1564">cv::Mat::data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the data </p>

</div>
</div>
<a class="anchor" id="a717e658d46d705f4c4863b67cade70d8"></a><!-- doxytag: member="cv::Mat::dataend" ref="a717e658d46d705f4c4863b67cade70d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_mat.html#a717e658d46d705f4c4863b67cade70d8">cv::Mat::dataend</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0dd9da61f74d2e82c38bf729baad5bdb"></a><!-- doxytag: member="cv::Mat::datalimit" ref="a0dd9da61f74d2e82c38bf729baad5bdb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_mat.html#a0dd9da61f74d2e82c38bf729baad5bdb">cv::Mat::datalimit</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c094be66d6a19b74c93d57a502a59d0"></a><!-- doxytag: member="cv::Mat::datastart" ref="a3c094be66d6a19b74c93d57a502a59d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="core_2include_2opencv2_2core_2types__c_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <a class="el" href="classcv_1_1_mat.html#a3c094be66d6a19b74c93d57a502a59d0">cv::Mat::datastart</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>helper fields used in locateROI and adjustROI </p>

</div>
</div>
<a class="anchor" id="a39cf614aa52567e9a945cd2609bd767b"></a><!-- doxytag: member="cv::Mat::dims" ref="a39cf614aa52567e9a945cd2609bd767b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_mat.html#a39cf614aa52567e9a945cd2609bd767b">cv::Mat::dims</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the matrix dimensionality, &gt;= 2 </p>

</div>
</div>
<a class="anchor" id="af9333f06c84f115fda4cdf3af18c2ad0"></a><!-- doxytag: member="cv::Mat::flags" ref="af9333f06c84f115fda4cdf3af18c2ad0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_mat.html#af9333f06c84f115fda4cdf3af18c2ad0">cv::Mat::flags</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>includes several bit-fields:</p>
<ul>
<li>the magic signature</li>
<li>continuity flag</li>
<li>depth</li>
<li>number of channels </li>
</ul>

</div>
</div>
<a class="anchor" id="a731b10faf33879e2d6a0ebd0fcce4ce4"></a><!-- doxytag: member="cv::Mat::refcount" ref="a731b10faf33879e2d6a0ebd0fcce4ce4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classcv_1_1_mat.html#a731b10faf33879e2d6a0ebd0fcce4ce4">cv::Mat::refcount</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>pointer to the reference counter; </p>

</div>
</div>
<a class="anchor" id="abed816466c45234254d25bc59c31245e"></a><!-- doxytag: member="cv::Mat::rows" ref="abed816466c45234254d25bc59c31245e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcv_1_1_mat.html#abed816466c45234254d25bc59c31245e">cv::Mat::rows</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>the number of rows and columns or (-1, -1) when the matrix has more than 2 dimensions </p>

</div>
</div>
<a class="anchor" id="a5500ed91b9300d78a62528c4f7bf1869"></a><!-- doxytag: member="cv::Mat::size" ref="a5500ed91b9300d78a62528c4f7bf1869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_mat_1_1_m_size.html">MSize</a> <a class="el" href="classcv_1_1_mat.html#a5500ed91b9300d78a62528c4f7bf1869">cv::Mat::size</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acc7e087cdfcaaba5df75ab6e9def9e85"></a><!-- doxytag: member="cv::Mat::step" ref="acc7e087cdfcaaba5df75ab6e9def9e85" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcv_1_1_mat_1_1_m_step.html">MStep</a> <a class="el" href="classcv_1_1_mat.html#acc7e087cdfcaaba5df75ab6e9def9e85">cv::Mat::step</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/jjthrash/Downloads/OpenCV-2.2.0/modules/core/include/opencv2/core/<a class="el" href="core_8hpp_source.html">core.hpp</a></li>
<li>/Users/jjthrash/Downloads/OpenCV-2.2.0/modules/core/include/opencv2/core/<a class="el" href="mat_8hpp_source.html">mat.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Feb 21 2011 10:00:54 for opencv by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
